# [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
## Задача
Учитывая, что массив целых чисел `nums` отсортирован в **неубывающем порядке**, удалите дубликаты [**на месте**](https://en.wikipedia.org/wiki/In-place_algorithm) таким образом, чтобы каждый уникальный элемент появлялся только **один раз**. **Относительный порядок** элементов должен быть **таким же**. Затем верните _количество уникальных элементов в_ `nums`.

Учтите количество уникальных элементов `nums`, которое должно быть `k`, чтобы быть принятым, вам нужно выполнить следующие действия:

- Измените массив `nums` таким образом, чтобы первые `k` элементы `nums` содержали уникальные элементы в том порядке, в котором они присутствовали `nums` изначально. Остальные элементы `nums` не так важны, как размер `nums`.
- Возврат`k`.
```
Пример 1:
Ввод: nums = [1,1,2]
Вывод: 2, nums = [1,2,_]
Объяснение: Ваша функция должна возвращать k = 2, при этом первые два элемента nums равны 1 и 2 соответственно.
Не имеет значения, что вы оставляете за пределами возвращаемого k (следовательно, они являются символами подчеркивания).

Пример 2:
Ввод: nums = [0,0,1,1,1,2,2,3,3,4]
Вывод: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Объяснение: Ваша функция должна возвращать k = 5, при этом первые пять элементов nums равны 0, 1, 2, 3 и 4 соответственно.
Не имеет значения, что вы оставляете за пределами возвращаемого k (следовательно, они являются символами подчеркивания).
```
## Идея
Использовать два указателя. Предыдущий и текущий элементы. Сравнивать значения.
Если текущее значение равно предыдущему, то заменить его и подвинуть указатель текущего. Если предыдущее равно пустому, то сдвинуть указатель и поменять значения местами текущий на предыдущий. Если предыдущий не равен текущему и не пустой символ, то сдвинуть его вперед. 

## Нюансы
- Текущий элемент должен быть всегда впереди предыдущего
## Решение
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        prev = 0
        current = 1

        while current < len(nums):
            if nums[prev] == '_':
                nums[prev], nums[current] = nums[current], nums[prev]
                current += 1

            elif nums[current] == nums[prev]:
                nums[current] = '_'
                current += 1

            else:
                prev += 1
            
            current = max(current, prev + 1)

        return prev + 1
```
Оценка по памяти `O(1)`

Оценка по времени `O(n)`
