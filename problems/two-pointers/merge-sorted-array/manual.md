# [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)
## Задача
Вам предоставлены два массива целых чисел `nums1` и `nums2`, отсортированные в **неубывающем порядке**, и два целых числа `m` и `n`, представляющих количество элементов в `nums1` и `nums2` соответственно.

**Объединить** `nums1` и `nums2` в единый массив, отсортированный в **неубывающем порядке**.

Окончательный отсортированный массив не должен быть возвращен функцией, но вместо этого должен быть _сохранен внутри массива_ `nums1`. Чтобы учесть это, `nums1` имеет длину `m + n`, где первые `m` элементы обозначают элементы, которые должны быть объединены, а последние `n` элементы имеют значение `0` и их следует игнорировать. `nums2` имеет длину `n`.
```
Пример 1:
Входные данные: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 
Вывод: [1,2,2,3,5,6]
Объяснение: Объединяемыми массивами являются [1,2,3] и [2,5,6].
Результатом слияния является [1,2,2,3, 5,6] с подчеркнутыми элементами, взятыми из nums1.

Пример 2:
Входные данные: nums1 = [1], m = 1, nums2 = [], n = 0 
Выходные данные: [1]
Объяснение: Объединяемыми массивами являются [1] и [].
Результатом слияния является [1].

Пример 3:
Входные данные: nums1 = [0], m = 0, nums2 = [1], n = 1 
Выходные данные: [1]
Объяснение: Объединяемыми массивами являются [] и [1].
Результатом слияния является [1].
Обратите внимание, что, поскольку m = 0, в nums1 нет элементов. 0 указано только для того, чтобы результат слияния поместился в nums1.
```
## Идея
Заполнять массив с максимальных элементов. Использовать 3 указателя. 
Указатель "куда ставим" ставится на правый нуль. Указатель левого массива на правый максимальный элемент. Указатель правого массива на правый максимальный элемент.
В цикле перебираем, сравниваем левый и правый, какой больше, тот и записываем под указатель "куда ставим" и смещаем их.
## Нюансы
- Если правый массив пустой, но цикл останавливается т.к. смысл заканчивается
- m и n индексируется с 1, поэтому вначале надо вычесть из них по единице
## Решение
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        m -= 1
        n -= 1
        zero_cell = len(nums1) - 1

        while zero_cell >= 0 and n >= 0:
            if m < 0 or nums1[m] < nums2[n]:
                nums1[zero_cell] = nums2[n]
                n -= 1
            else:
                nums1[zero_cell] = nums1[m]
                m -= 1

            zero_cell -= 1
```
Оценка по памяти `O(1)`

Оценка по времени `O(n+m)`
