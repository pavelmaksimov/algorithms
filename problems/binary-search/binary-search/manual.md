# [Binary Search](https://leetcode.com/problems/binary-search/)
## Задача
Учитывая массив целых чисел, `nums` который отсортирован в порядке возрастания, и целое число `target`, напишите функцию для поиска `target` в `nums`. Если `target` существует, то верните его индекс. В противном случае верните `-1`.

Вы должны написать алгоритм со `O(log n)` сложностью во время выполнения.

```
Пример 1:
Ввод: числа = [-1,0,3,5,9,12], target = 9 
Вывод:4 
Объяснение: 9 существует в nums, и его индекс равен 4

Пример 2:
Входные данные: числа = [-1,0,3,5,9,12], target = 2 
Выходные данные:-1 
Объяснение: 2 не существует в nums, поэтому возвращает -1
```
## Идея
Написать такую функцию сравнения, которая может проставить всем значениям true/false и граница между элементами последовательностей будет проходить там, где находится нужное значение. Левый указатель должен указывать на последний элемент последовательности true, а правый указатель на первый элемент последовательности `false`.
## Решение
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
    
        check = lambda x: nums[x] <= target

        l, r = 0, len(nums)

        while r - l > 1:
            mid = (r + l) // 2 

            if check(mid):
                l = mid
            else:
                r = mid
            
        return l if nums[l] == target else -1
```
Оценка по памяти `O(1)`

Оценка по времени `O(log n)`
