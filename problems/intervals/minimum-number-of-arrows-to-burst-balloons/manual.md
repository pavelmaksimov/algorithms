# [Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

## Задача
На горизонте расположены воздушные шары. Есть точки их начала и конца. Определить минимум выстрелов, чтобы их всех сбить.
```
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2

Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4

Constraints:

1 <= points.length <= 105
points[i].length == 2
-231 <= xstart < xend <= 231 - 1
```
## Идея
Пытаться объединить интервалы. Если это возможно, значит их можно сбить одни выстрелом. Надо уменьшить интервал до интервала пересечения.
## Решение
- Отсортировать массив по начальным точкам
- Создать массив `result`, чтоб складывать туда интервалы пересечения
- Положить туда первый интервал
- В цикле сравнивать текущий и предыдущий интервалы
-  Если начало текущего меньше или равно концу предыдущему, значит они пересекаются
- Если интервалы пересекаются, то уменьшить интервал в `result` до точек интервала пересечения
- Если нет, то добавить текущий интервал в `result`
- В конце вернуть кол-во интервалов в `result`

```python
class Solution:  
    def findMinArrowShots(self, points: List[List[int]]) -> int:  
        points.sort(key=lambda x: x[0])  
        result = [points[0]]  
      
        for p in points:  
            if p[0] <= result[-1][1]:  
                result[-1][0] = max(result[-1][0], p[0])  
                result[-1][1] = min(result[-1][1], p[1])  
            else:  
                result.append(p)  
      
        return len(result)
```

Оценка по памяти O(n), из-за сортировки, без неё O(n) 
т.к. в худшем случае в массив result будут сложены все интервалы.

Оценка по времени O(n log n) из-за сортировки, без неё O(n)
