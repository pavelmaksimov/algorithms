# [Video Stitching](https://leetcode.com/problems/video-stitching/)

## Задача
Вам будет предоставлена серия видеоклипов со спортивного мероприятия, которые длились `time` секунды. Эти видеоклипы могут накладываться друг на друга и иметь разную длину.

Каждый видеоклип описывается массивом, `clips` где `clips[i] = [starti, endi]` указывается, что i-й клип начинался с `starti` и заканчивался на `endi`.

Мы можем свободно разрезать эти клипы на сегменты.

- Например, клип `[0, 7]` можно разрезать на сегменты `[0, 1] + [1, 3] + [3, 7]`.

Верните _минимальное количество клипов, необходимое для того, чтобы мы могли разрезать клипы на сегменты, охватывающие все спортивное мероприятие_ `[0, time]`. Если задача невыполнима, верните `-1`.
```
Example 1:

Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10
Output: 3
Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
Example 2:

Input: clips = [[0,1],[1,2]], time = 5
Output: -1
Explanation: We cannot cover [0,5] with only [0,1] and [1,2].
Example 3:

Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9
Output: 3
Explanation: We can take clips [0,4], [4,7], and [6,9].
```
## Идея
Пытаться объединить интервалы. Если это возможно, то внимательно обрезать начало роликов до конца предыдущего ролика. Если интервалы невозможно объединить, значит видео будет не полным.
## Решение
- Отсортировать массив по начальным точкам
- Запомнить последний интервал пересечения в переменной, в начале это первый интервал
- Проверяем первый интервал, чтоб начало было 0, иначе вернуть -1
- Создать счетчик интервалов для полного видео
- Начинаем цикл со второго элемента
- В цикле сравнивать текущий и последний интервал
-  Если начало текущего больше конца последнего, они не пересекаются, значит невозможно соединить полное видео, вернуть ответ -1
- Иначе, если конец текущего меньше или равен последнему, такой нам не интересен
- Иначе, если начало текущего меньше или равно последнему и конец текущего длиннее последнего, значит последний выкидывается, его можно заменить текущим, перед этим у текущего обрезать начало ролика до начала последнего, счетчик не увеличивается
- Иначе, если начало текущего больше начала последнего интервала и конец текущего длиннее последнего, обрезать начало текущего ролика до конца последнего ролика, заменить последний на текущий и увеличить счетчик
- Если получили полное видео, остановить цикл, вернуть результат
## Нюансы
- Проверять, что начала и конец ролика составляют все видео.
- Внимательно обрезать лишние концы интервалов, если они есть в других роликах, которые были взяты. Это позволяет правильно понять, какие другие ролики подойдут.

```python
class Solution:
    def videoStitching(self, clips: List[List[int]], time: int) -> int:
        clips.sort(key=lambda x: x[0])
        counter = 1
        last = clips[0]

        if last[0] > 0:
            return -1

        for i in range(1, len(clips)):
            if last[1] >= time:
                return counter

            current = clips[i]
            
            if current[0] > last[1]:
                # Если начало текущего больше конца последнего, они не пересекаются, значит невозможно соединить полное видео.
                return -1
            elif current[1] <= last[1]:
                # Если конец текущего меньше последнего, такой нам не интересен.
                continue
            elif current[0] <= last[0]:
                # Конец текущего длинее последнего.
                # Если начало текущего меньше или равно началу последнго и конец текущего длиннее последнего, значит последний выкидывается, его можно заменить.
                # Меньше не может быть, потому что они отсортированы по началам.
                current[0] = last[0]
                last = current
            else:
                # Если начало текущего больше начала последнего интервала и конец текущего длиннее последнего,
                # Увеличить счетчик и сдвинуть начало текущего до конца последнего и заменить последний на текущий.
                counter += 1
                current[0] = last[1]
                last = current
            
        if last[1] < time:
            return -1

        return counter
```
Оценка по памяти `O(n)`, из-за сортировки, без неё `O(1)`

Оценка по времени `O(n log n)` из-за сортировки, без неё `O(n)`
