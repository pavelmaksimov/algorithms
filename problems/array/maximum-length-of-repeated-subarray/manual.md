# [Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)

## Задача
Учитывая два массива целых чисел `nums1` и `nums2`, верните _максимальную длину подмассива, которая отображается в **обоих** массивах_.
```
Пример 1:
Входные данные: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Вывод:3 
Пояснение: Повторяющийся подмассив с максимальной длиной равен [3,2,1].

Пример 2:
Входные данные: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Результат:5 
Пояснение: Повторяющийся подмассив с максимальной длиной равен [0,0,0,0,0].
```
## Идея
Самое простое это сравнивать строку в строке. Поэтому надо работать со строками. 
Сравниваем срез, накапливая в цикле по одному символу. 
Если при проверке на вхождение среза такого нет, сокращаем его на один символ от начала. 

## Решение
- Создаем переменную для хранения максимальной длины
- создаем строку из num2, преобразовав числа в символы unicode `chr() `
- создаем срез/набор символов, который будем проверять на вхождение
- далее запускаем цикл по nums1
- добавляем в срез символ из nums1
- Проверяем срез на вхождение в nums2
- Если есть, увеличиваем максимальную длину
- Если нет, убираем из среза первый символ, т.к. с ним нет вхождений
```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        max_length = 0
        chunk = ''
        nums2 = ''.join(chr(x) for x in nums2)

        for num in nums1:
            chunk += chr(num)
            if chunk in nums2:
                max_length = max(max_length, len(chunk))
            else:
                chunk = chunk[1:]

        return max_length
```
Оценка по памяти `O()`

Оценка по времени `O()`
